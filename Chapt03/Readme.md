## Pure?

### 1. Pure Function

Pure Function은 수학의 함수와 같은 성질을 가진다.
- input 값이 같으면 output 값도 동일해야한다.
- (추가적으로) 함수 내부에서 외부의 상태를 변경하지 않아야한다.

### 2. Side Effect
다음과 같은 Impure Function은 Side Effect를 가진다.
- 전역 변수를 변경하는 함수
- 입력 인수를 변경하는 함수
- Exception을 던지는 함수
- IO를 수행하는 함수 (db, 콘솔, 웹 API 등)

Pure Function은 Side Effect가 없다. 

- Side Effect가 없는 함수는 항상 Pure Function은 아니다. 전역 상태에 의존하면 입력 이외의 요소에 의해 결과값이 달라질 수 있다.
- 출력 값이 전적으로 입력 값에 의해 결정 되더라도, 함수가 외부 상태를 변경하면 Side Effect를 유발한다.

### 3. 메리트
Pure Function은 다음과 같은 메리트를 가진다.
- 테스트가 용이하다.
  - 대수학적 구조를 이용해, 입력값에 따른 결과값을 예측하기 쉽다.
- 병렬 처리가 용이하다.
  - 다른 스레드에서도 동일한 결과를 보장하므로, 동시에 실행해도 안전하다.
  - Pure하지 않는 경우, thread-safe 를 하기 지키기위해, Locking 등의 공유 잠금 메커니즘을 사용해야하는데 이는 당연히 성능 저하를 초래한다.
- Lazy Evaluation이 가능하다.
  - Evaluation의 시점이 중요하지 않아, 필요할 때만 Evaluation이 가능하다. 
- Memoization이 가능하다. 
  - 한번 캐싱 된 결과를 재사용 할 수 있다.

### 4. 동시성의 여러 컨텍스트
- 비동기성
  - 앱이 스레드의 차단 없이 작업을 수행한다. 응답을 기다리는 동안, 스레드 풀에 다른 작업을 할당한다.
- 병렬성 
  - 멀티코어 프로세서에서 앱에 여러 작업을 동시에 수행한다. 

### 5. Purity
애플리케이션을 구현하다보면, I/O와 관련된 Side Effect를 피할 수는 없다. 파일 입출력이나, 외부 API의 명세 변경, 현재 시간 호출 등 항상 동일한 결과를 보장할 수 없는 것에 의존 하는 경우가 생긴다.
그럼 어떻게 해야할까?

1. I/O 를 수행하는 함수를 제외한 나머지 함수는 Pure Function으로 구현한다.
2. 로직의 파이프라인에 I/O 를 수행 하는 영역을 가장 끝 쪽에 배치한다.

### 6. Functional DI
테스트를 위해 OOP DI 패턴을 사용하면, 테스트를 위한 인터페이스를 만들어야하고, 이를 구현하는 클래스를 만들어야한다.
이는 사용하는 클래스가 한 개 밖에 없는 경우에도 인터페이스를 만들어야하는 번거로움이 있다.

Functional DI는 이를 해결한다.
..BasedDI.cs 참조
